/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : NSSpeechRecognizer
 #	author : miyako
 #	2018/05/10
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

@interface Listener : NSObject <NSSpeechRecognizerDelegate>
{
	NSSpeechRecognizer *recognizer;
}

- (id)init;

//not called?
//- (void)dealloc;

- (void)end;

- (id)start;
- (id)stop;
- (id)update;

@end

namespace SR
{
	Listener *listener = nil;
	
	process_number_t METHOD_PROCESS_ID = 0;
	process_stack_size_t STACK_SIZE = 512*1024;
	process_name_t PROCESS_NAME = (PA_Unichar *)"$\0S\0P\0E\0E\0C\0H\0_\0R\0E\0C\0O\0G\0N\0I\0Z\0E\0R\0\0\0";

	C_TEXT LISTENER_METHOD;
	C_TEXT LISTENER_TITLE;
	ARRAY_TEXT LISTENER_COMMANDS;
	bool listensInForegroundOnly = 1;
	bool blocksOtherRecognizers = 0;
	
	/* param1 */
	std::vector<CUTF16String>RECOGNIZED_COMMANDS;

	/* signal */
	bool PROCESS_SHOULD_TERMINATE = false;
}

@implementation Listener

- (id)init
{
	if(!(self = [super init])) return self;
	
	recognizer = [[NSSpeechRecognizer alloc]init];
	
	recognizer.delegate = self;
	
	[self start];
	
	return self;
}


- (void)end
{
	[recognizer stopListening];
	[recognizer release];
	recognizer = nil;
}

- (void)speechRecognizer:(NSSpeechRecognizer *)sender didRecognizeCommand:(NSString *)command
{
	C_TEXT t;
	t.setUTF16String(command);
	CUTF16String c;
	t.copyUTF16String(&c);
	SR::RECOGNIZED_COMMANDS.push_back(c);
	
	listenerLoopExecute();
}

-(void)start
{
	[self update];
	
	recognizer.listensInForegroundOnly = SR::listensInForegroundOnly;
	recognizer.blocksOtherRecognizers = SR::blocksOtherRecognizers;
	
	[recognizer startListening];
}

-(void)stop
{
	[recognizer stopListening];
}

- (id)update
{
	NSUInteger capacity = SR::LISTENER_COMMANDS.getSize();
	NSMutableArray *commands = [[NSMutableArray alloc]initWithCapacity:capacity];
	
	for(NSUInteger i = 0;i < capacity; ++i)
	{
		NSString *command = SR::LISTENER_COMMANDS.copyUTF16StringAtIndex(i);
		if(![command isEqualToString:@""]) [commands addObject:command];
		[command release];
	}
	
	recognizer.commands = commands;
	
	[commands release];
	
	if((SR::LISTENER_TITLE.getUTF16Length()) && (recognizer.commands.count))
	{
		NSString *title = SR::LISTENER_TITLE.copyUTF16String();
		recognizer.displayedCommandsTitle = title;
		[title release];
	}else
	{
		recognizer.displayedCommandsTitle = nil;
	}
	
}

@end

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

#pragma mark -

void listenerLoop()
{
	SR::listener = [[Listener alloc]init];
	
	SR::PROCESS_SHOULD_TERMINATE = false;
	
	while(!SR::PROCESS_SHOULD_TERMINATE)
	{
		PA_YieldAbsolute();
		
		while(SR::RECOGNIZED_COMMANDS.size())
		{
			listenerLoopExecuteMethod();

			if(SR::PROCESS_SHOULD_TERMINATE)
				break;
		}
		
		if(!SR::PROCESS_SHOULD_TERMINATE)
		{
			PA_FreezeProcess(PA_GetCurrentProcessNumber());
		}
	}
	
	[SR::listener end];
	SR::listener = nil;
	
	SR::METHOD_PROCESS_ID = 0;
	
	PA_KillProcess();
}

void listenerLoopStart()
{
	if(!SR::METHOD_PROCESS_ID)
	{
		SR::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
																					SR::STACK_SIZE,
																					SR::PROCESS_NAME);
	}
}

void listenerLoopFinish()
{
	if(SR::METHOD_PROCESS_ID)
	{
		SR::PROCESS_SHOULD_TERMINATE = true;

		PA_YieldAbsolute();

		SR::RECOGNIZED_COMMANDS.clear();
		SR::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);

		PA_UnfreezeProcess(SR::METHOD_PROCESS_ID);
	}
}

void listenerLoopExecute()
{
	SR::PROCESS_SHOULD_TERMINATE = false;
	PA_UnfreezeProcess(SR::METHOD_PROCESS_ID);
}

void listenerLoopExecuteMethod()
{
	std::vector<CUTF16String>::iterator cc = SR::RECOGNIZED_COMMANDS.begin();

	method_id_t methodId = PA_GetMethodID((PA_Unichar *)SR::LISTENER_METHOD.getUTF16StringPtr());
	
	if(methodId)
	{
		/* param1 */
		PA_Variable	params[1];
		params[0] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring command = PA_CreateUnistring((PA_Unichar *)cc->c_str());
		PA_SetStringVariable(&params[0], &command);

		/* execute method */
		SR::RECOGNIZED_COMMANDS.erase(cc);
		PA_ExecuteMethodByID(methodId, params, 1);
		PA_ClearVariable(&params[0]);
	}else{
		
		/* param1 */
		PA_Variable	params[2];
		params[1] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring command = PA_CreateUnistring((PA_Unichar *)cc->c_str());
		PA_SetStringVariable(&params[1], &command);
		
		params[0] = PA_CreateVariable(eVK_Unistring);
		PA_Unistring method = PA_CreateUnistring((PA_Unichar *)SR::LISTENER_METHOD.getUTF16StringPtr());
		PA_SetStringVariable(&params[0], &method);

		/* execute method */
		PA_ExecuteCommandByID(1007, params, 2);
		SR::RECOGNIZED_COMMANDS.erase(cc);
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
	}
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
	
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		listenerLoopFinish();
	}
}

#pragma mark -

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			
			// --- NSSpeechRecognizer

		case 1 :
			START_SPEECH_RECOGNIZER(pResult, pParams);
			break;

		case 2 :
			SET_SPEECH_COMMANDS(pResult, pParams);
			break;

		case 3 :
			GET_SPEECH_COMMANDS(pResult, pParams);
			break;

		case 4 :
			STOP_SPEECH_RECOGNIZER(pResult, pParams);
			break;

		case 5 :
			QUIT_SPEECH_RECOGNIZER(pResult, pParams);
			break;
	}
}

// ------------------------------ NSSpeechRecognizer ------------------------------

#pragma mark JSON

void json_wconv(const char *value, std::wstring &u32)
{
	if((value) && strlen(value))
	{
		C_TEXT t;
		CUTF8String u8 = CUTF8String((const uint8_t *)value);
		
		t.setUTF8String(&u8);
		
#if VERSIONWIN
		u32 = std::wstring((wchar_t *)t.getUTF16StringPtr());
#else
		uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
		std::vector<char> buf(dataSize);
		
		PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
															 t.getUTF16Length() * sizeof(PA_Unichar),
															 eVTC_UTF_16,
															 (char *)&buf[0],
															 dataSize,
															 eVTC_UTF_32);
		
		u32 = std::wstring((wchar_t *)&buf[0]);
#endif
	}else
	{
		u32 = L"";
	}
	
}

void json_wconv(const wchar_t *value, CUTF16String *u16)
{
	size_t wlen = wcslen(value);
	
#if VERSIONWIN
	*u16 = CUTF16String((const PA_Unichar *)value, wlen);
#else
	uint32_t dataSize = (uint32_t)((wlen * sizeof(wchar_t))+ sizeof(PA_Unichar));
	std::vector<char> buf(dataSize);
	//returns byte size in toString (in this case, need to /2 to get characters)
	uint32_t len = PA_ConvertCharsetToCharset((char *)value,
																						(PA_long32)(wlen * sizeof(wchar_t)),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	*u16 = CUTF16String((const PA_Unichar *)&buf[0], len/sizeof(PA_Unichar));
#endif
}

#pragma mark -

void START_SPEECH_RECOGNIZER(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_method;
	C_TEXT Param2_options;

	SR::LISTENER_METHOD.fromParamAtIndex(pParams, 1);
	Param2_options.fromParamAtIndex(pParams, 2);
	
	CUTF8String _Param2_options;
	Param2_options.copyUTF8String(&_Param2_options);
	std::wstring __Param2_options;
	json_wconv((const char *)_Param2_options.c_str(), __Param2_options);
	JSONNODE *option = json_parse(__Param2_options.c_str());

	if(option)
	{
		if (json_type(option) == JSON_NODE)
		{
			JSONNODE_ITERATOR i = json_begin(option);
			while (i != json_end(option))
			{
				JSONNODE *n = *i;
				if(n)
				{
					json_char *name = json_name(n);
					if(name)
					{
						std::wstring s = std::wstring((const wchar_t *)name);
						if (s.compare(L"displayedCommandsTitle") == 0)
						{
							json_char *value = json_as_string(n);
							if(value)
							{
								CUTF16String u16;
								json_wconv(value, &u16);
								SR::LISTENER_TITLE.setUTF16String(&u16);
								json_free(value);
							}
							goto __exit;
						}
						if (s.compare(L"listensInForegroundOnly") == 0)
						{
							SR::listensInForegroundOnly = json_as_bool(n);
							goto __exit;
						}
						if (s.compare(L"blocksOtherRecognizers") == 0)
						{
							SR::blocksOtherRecognizers = json_as_bool(n);
							goto __exit;
						}
						__exit:
						json_free(name);
					}
				}
				++i;
			}
		}
		json_delete(option);
	}

	listenerLoopStart();
	
	if(SR::listener)
	{
		[SR::listener start];
	}
}

void SET_SPEECH_COMMANDS(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;

	SR::LISTENER_COMMANDS.fromParamAtIndex(pParams, 1);
	
	if(SR::listener)
	{
		[SR::listener update];
	}
}

void GET_SPEECH_COMMANDS(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;

	SR::LISTENER_COMMANDS.toParamAtIndex(pParams, 1);
}

void STOP_SPEECH_RECOGNIZER(sLONG_PTR *pResult, PackagePtr pParams)
{
	if(SR::listener)
	{
		[SR::listener stop];
	}
}

void QUIT_SPEECH_RECOGNIZER(sLONG_PTR *pResult, PackagePtr pParams)
{
	listenerLoopFinish();
}
